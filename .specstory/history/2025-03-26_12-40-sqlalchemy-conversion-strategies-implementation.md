<!-- Generated by SpecStory -->

# SQLAlchemy Conversion Strategies Implementation (2025-03-26 09:40:31)

_**User**_


**Instructions for Developers:**

1.  **Create the Python files** listed below within the specified directory (`politipo/core/conversion/strategies/`).
2.  **Copy the provided code** into each corresponding file.
3.  **Register these new strategies** with your `ConversionEngine` instance where you initialize Politipo.

```python
# Example of registration (in your main setup, e.g., main.py or similar)
from politipo import ConversionEngine
# Import your existing strategies
from politipo.core.conversion.strategies import (
    ModelToDictStrategy,
    DictToModelStrategy,
    PandasToModelListStrategy,
    ListToPandasStrategy,
    ListToPolarsStrategy,
    PolarsToListStrategy,
)
# Import the NEW strategies
from politipo.core.conversion.strategies.sqlalchemy_model_to_dict import SQLAlchemyModelToDictStrategy
from politipo.core.conversion.strategies.dict_to_sqlalchemy_model import DictToSQLAlchemyModelStrategy
from politipo.core.conversion.strategies.model_to_sqlalchemy_model import ModelToSQLAlchemyModelStrategy
from politipo.core.conversion.strategies.sqlalchemy_model_to_model import SQLAlchemyModelToModelStrategy

# Initialize the engine
engine = ConversionEngine()

# Register Type Systems (as you already do)
# engine.register_type_system(...)
# engine.register_type_system(...)

# Register Existing Strategies (example)
engine.register_strategy(ModelToDictStrategy())
engine.register_strategy(DictToModelStrategy())
# ... register other existing strategies

# *** REGISTER NEW STRATEGIES ***
engine.register_strategy(SQLAlchemyModelToDictStrategy())
engine.register_strategy(DictToSQLAlchemyModelStrategy())
engine.register_strategy(ModelToSQLAlchemyModelStrategy())
engine.register_strategy(SQLAlchemyModelToModelStrategy())

# Now the engine can use these new conversion paths
```

---

## Task 1: Implement SQLAlchemy Model -> Dict Strategy

**Goal:** Convert an instance of an SQLAlchemy declarative model into a Python dictionary containing its column values.

**File:** `politipo/core/conversion/strategies/sqlalchemy_model_to_dict.py`

```python
# politipo/core/conversion/strategies/sqlalchemy_model_to_dict.py

from typing import Any, Dict

from politipo.core.types import CanonicalType
from politipo.core.conversion.context import ConversionContext
from politipo.core.conversion.strategies.base import ConversionStrategy
from politipo.core.errors import ConversionError, PolitipoError

# Attempt to import SQLAlchemy components, required for type checking and logic
try:
    from sqlalchemy.orm.attributes import instance_state
    _SQLA_AVAILABLE = True
except ImportError:
    _SQLA_AVAILABLE = False
    # Define dummy for type hinting if needed, though runtime checks handle absence
    instance_state = None


class SQLAlchemyModelToDictStrategy(ConversionStrategy):
    """Strategy for converting SQLAlchemy model instances to dictionaries."""

    def can_handle(self, source: CanonicalType, target: CanonicalType) -> bool:
        """
        Returns True if the source is a SQLAlchemy model and the target is a dict.
        Relies on metadata set by SQLAlchemyModelTypeSystem.
        """
        return (
            source.kind == "composite" and
            source.meta is not None and
            source.meta.get("origin_system") == "sqlalchemy_model" and
            target.kind == "container" and
            target.name == "dict"
        )

    def convert(self, value: Any, context: ConversionContext) -> Dict[str, Any]:
        """
        Convert an SQLAlchemy model instance to a dictionary.

        Args:
            value: The SQLAlchemy model instance to convert.
            context: The conversion context.

        Returns:
            A dictionary representing the model's column data.

        Raises:
            ConversionError: If the input is not a valid SQLAlchemy model instance
                             or if conversion fails.
            PolitipoError: If SQLAlchemy is not installed.
        """
        if not _SQLA_AVAILABLE:
            raise PolitipoError("SQLAlchemy is required for SQLAlchemyModelToDictStrategy")

        # Basic check: Does it look like an SQLAlchemy model instance?
        # A more robust check might involve checking instance_state
        if not hasattr(value, '__table__') or not hasattr(value, '__class__'):
             # Try checking instance state as a more reliable indicator
             try:
                 state = instance_state(value)
                 if not state:
                     raise AttributeError # Not an instrumented instance
             except (AttributeError, TypeError):
                 raise ConversionError(f"Expected an SQLAlchemy model instance, got {type(value)}")

        try:
            # Extract column names from the model's table definition
            column_names = [c.name for c in value.__table__.columns]

            # Build the dictionary using getattr
            data_dict = {}
            for col_name in column_names:
                # Use getattr to retrieve the value; handle potential unloaded attributes
                # Note: This might trigger lazy loading if attributes are not loaded.
                # For complex scenarios, pre-loading attributes might be needed.
                try:
                    data_dict[col_name] = getattr(value, col_name)
                except AttributeError:
                    # This shouldn't typically happen for mapped columns, but handle defensively
                    data_dict[col_name] = None # Or raise an error? Default to None for safety.

            return data_dict
        except AttributeError as e:
             # Catch errors like value.__table__ not existing if the initial check failed
            raise ConversionError(f"Failed to access SQLAlchemy model properties: {e}") from e
        except Exception as e:
            # Catch other potential errors during attribute access or processing
            raise ConversionError(f"Failed to convert SQLAlchemy model instance to dict: {e}") from e

```

---

## Task 2: Implement Dict -> SQLAlchemy Model Strategy

**Goal:** Convert a Python dictionary into an instance of a specific SQLAlchemy declarative model.

**File:** `politipo/core/conversion/strategies/dict_to_sqlalchemy_model.py`

```python
# politipo/core/conversion/strategies/dict_to_sqlalchemy_model.py

from typing import Any, Dict, Type

from politipo.core.types import CanonicalType
from politipo.core.conversion.context import ConversionContext
from politipo.core.conversion.strategies.base import ConversionStrategy
from politipo.core.errors import ConversionError, PolitipoError

# Attempt to import SQLAlchemy components
try:
    from sqlalchemy.orm import DeclarativeMeta
    _SQLA_AVAILABLE = True
except ImportError:
    _SQLA_AVAILABLE = False
    DeclarativeMeta = None


class DictToSQLAlchemyModelStrategy(ConversionStrategy):
    """Strategy for converting dictionaries to SQLAlchemy model instances."""

    def can_handle(self, source: CanonicalType, target: CanonicalType) -> bool:
        """
        Returns True if the source is a dict and the target is a SQLAlchemy model.
        Relies on metadata set by SQLAlchemyModelTypeSystem.
        """
        return (
            source.kind == "container" and
            source.name == "dict" and
            target.kind == "composite" and
            target.meta is not None and
            target.meta.get("origin_system") == "sqlalchemy_model"
        )

    def convert(self, value: Any, context: ConversionContext) -> Any:
        """
        Convert a dictionary to an SQLAlchemy model instance.

        Args:
            value: The dictionary to convert.
            context: The conversion context containing target type information.

        Returns:
            An instance of the target SQLAlchemy model.

        Raises:
            ConversionError: If the input is not a dict, the target type system
                             is missing, the target model class cannot be resolved,
                             or instantiation fails.
            PolitipoError: If SQLAlchemy is not installed.
        """
        if not _SQLA_AVAILABLE:
            raise PolitipoError("SQLAlchemy is required for DictToSQLAlchemyModelStrategy")

        if not isinstance(value, dict):
            raise ConversionError(f"Expected dict, got {type(value)}")

        # Get the target SQLAlchemy model class from the context
        if not context.target_type_system:
            raise ConversionError("Target type system (SQLAlchemyModelTypeSystem) not found in context")

        try:
            # Use the target system to reconstruct the model class from the canonical type
            model_class: Type = context.target_type_system.from_canonical(context.target)
            if not isinstance(model_class, type) or not hasattr(model_class, '__table__'):
                 # Check if it's a DeclarativeMeta type
                 if not isinstance(getattr(model_class, '__class__', None), DeclarativeMeta):
                      raise ConversionError(f"Target system did not return a valid SQLAlchemy model class for {context.target.name}")

        except NotImplementedError:
            raise ConversionError(f"Target system '{context.target_type_system.name}' cannot reconstruct model from canonical type.")
        except Exception as e:
            raise ConversionError(f"Failed to get target SQLAlchemy model class from canonical type: {e}") from e

        # Instantiate the model
        try:
            # Filter dict keys based on model columns if not in strict mode
            data_to_instantiate = value
            if not context.strict:
                valid_column_names = {c.name for c in model_class.__table__.columns}
                data_to_instantiate = {k: v for k, v in value.items() if k in valid_column_names}

            # Instantiate using **kwargs
            # Note: This assumes the dictionary keys match model attribute names.
            # Complex relationships or non-column attributes might require custom handling
            # or should be set after initial instantiation if needed.
            instance = model_class(**data_to_instantiate)
            return instance
        except TypeError as e:
            # Catch errors like unexpected keyword arguments
             if context.strict:
                 raise ConversionError(f"Failed to instantiate {model_class.__name__} with data {value}. Strict mode error: {e}") from e
             else:
                 # Try again without filtering if initial filtering failed, though unlikely
                 try:
                     return model_class(**value)
                 except Exception as final_e:
                      raise ConversionError(f"Failed to instantiate {model_class.__name__} even in non-strict mode: {final_e}") from final_e
        except Exception as e:
            # Catch other potential instantiation errors
            raise ConversionError(f"Failed to create SQLAlchemy model instance of {model_class.__name__}: {e}") from e

```

---

## Task 3: Implement Pydantic/SQLModel -> SQLAlchemy Model Strategy

**Goal:** Convert an instance of a Pydantic or SQLModel model into an instance of a specific SQLAlchemy declarative model. This strategy will internally convert the source model to a dictionary first.

**File:** `politipo/core/conversion/strategies/model_to_sqlalchemy_model.py`

```python
# politipo/core/conversion/strategies/model_to_sqlalchemy_model.py

from typing import Any, Dict, Type

from politipo.core.types import CanonicalType
from politipo.core.conversion.context import ConversionContext
from politipo.core.conversion.strategies.base import ConversionStrategy
from politipo.core.errors import ConversionError, PolitipoError
from politipo.core.utils.pydantic import get_pydantic_version # To check for model_dump/dict

# Attempt to import SQLAlchemy components
try:
    from sqlalchemy.orm import DeclarativeMeta
    _SQLA_AVAILABLE = True
except ImportError:
    _SQLA_AVAILABLE = False
    DeclarativeMeta = None

# Attempt to import Pydantic components
try:
    from pydantic import BaseModel
    _PYDANTIC_AVAILABLE = True
except ImportError:
    _PYDANTIC_AVAILABLE = False
    BaseModel = None


class ModelToSQLAlchemyModelStrategy(ConversionStrategy):
    """
    Strategy for converting Pydantic/SQLModel instances to SQLAlchemy model instances.
    Internally converts the source model to a dictionary first.
    """

    def can_handle(self, source: CanonicalType, target: CanonicalType) -> bool:
        """
        Returns True if source is Pydantic/SQLModel and target is SQLAlchemy model.
        """
        return (
            source.kind == "composite" and
            source.meta is not None and
            source.meta.get("origin_system") in ("pydantic", "sqlmodel") and
            target.kind == "composite" and
            target.meta is not None and
            target.meta.get("origin_system") == "sqlalchemy_model"
        )

    def convert(self, value: Any, context: ConversionContext) -> Any:
        """
        Convert a Pydantic/SQLModel instance to an SQLAlchemy model instance.

        Args:
            value: The Pydantic or SQLModel instance.
            context: The conversion context.

        Returns:
            An instance of the target SQLAlchemy model.

        Raises:
            ConversionError: If conversion fails at any step.
            PolitipoError: If SQLAlchemy or Pydantic is not installed.
        """
        if not _SQLA_AVAILABLE:
            raise PolitipoError("SQLAlchemy is required for ModelToSQLAlchemyModelStrategy")
        if not _PYDANTIC_AVAILABLE:
             # Check specifically if it's a SQLModel type which also needs Pydantic
             is_sqlmodel_source = context.source.meta and context.source.meta.get("origin_system") == "sqlmodel"
             if is_sqlmodel_source:
                 raise PolitipoError("Pydantic (dependency of SQLModel) is required for ModelToSQLAlchemyModelStrategy")
             # Only raise if the source is explicitly Pydantic
             elif context.source.meta and context.source.meta.get("origin_system") == "pydantic":
                 raise PolitipoError("Pydantic is required for ModelToSQLAlchemyModelStrategy")
             # If source system unknown or different, let it proceed, maybe it has .dict() anyway


        # 1. Convert Source Model (Pydantic/SQLModel) to Dictionary
        try:
            if hasattr(value, "model_dump"):  # Pydantic v2 preferred
                data_dict = value.model_dump()
            elif hasattr(value, "dict"):      # Pydantic v1 fallback
                data_dict = value.dict()
            else:
                raise ConversionError(f"Source object {type(value)} does not have 'model_dump' or 'dict' method.")
        except Exception as e:
            raise ConversionError(f"Failed to convert source model {type(value).__name__} to dict: {e}") from e

        # 2. Get Target SQLAlchemy Model Class
        if not context.target_type_system:
            raise ConversionError("Target type system (SQLAlchemyModelTypeSystem) not found in context")
        try:
            model_class: Type = context.target_type_system.from_canonical(context.target)
            if not isinstance(model_class, type) or not hasattr(model_class, '__table__'):
                 # Check if it's a DeclarativeMeta type
                 if not isinstance(getattr(model_class, '__class__', None), DeclarativeMeta):
                      raise ConversionError(f"Target system did not return a valid SQLAlchemy model class for {context.target.name}")
        except Exception as e:
            raise ConversionError(f"Failed to get target SQLAlchemy model class: {e}") from e

        # 3. Instantiate SQLAlchemy Model from Dictionary
        try:
            # Filter dict keys based on model columns if not in strict mode
            data_to_instantiate = data_dict
            if not context.strict:
                valid_column_names = {c.name for c in model_class.__table__.columns}
                data_to_instantiate = {k: v for k, v in data_dict.items() if k in valid_column_names}

            instance = model_class(**data_to_instantiate)
            return instance
        except TypeError as e:
             if context.strict:
                 raise ConversionError(f"Failed to instantiate {model_class.__name__} from dict {data_dict}. Strict mode error: {e}") from e
             else:
                 # Try again without filtering if initial filtering failed
                 try:
                     return model_class(**data_dict)
                 except Exception as final_e:
                     raise ConversionError(f"Failed to instantiate {model_class.__name__} even in non-strict mode: {final_e}") from final_e
        except Exception as e:
            raise ConversionError(f"Failed to create SQLAlchemy model instance {model_class.__name__} from dict: {e}") from e

```

---

## Task 4: Implement SQLAlchemy Model -> Pydantic/SQLModel Strategy

**Goal:** Convert an instance of an SQLAlchemy declarative model into an instance of a Pydantic or SQLModel model. This strategy will internally convert the SQLAlchemy model to a dictionary first.

**File:** `politipo/core/conversion/strategies/sqlalchemy_model_to_model.py`

```python
# politipo/core/conversion/strategies/sqlalchemy_model_to_model.py

from typing import Any, Dict, Type

from politipo.core.types import CanonicalType
from politipo.core.conversion.context import ConversionContext
from politipo.core.conversion.strategies.base import ConversionStrategy
from politipo.core.errors import ConversionError, PolitipoError
from politipo.core.conversion.utils.instantiation import create_model_instance_from_dict # Helper for Pydantic/SQLModel

# Attempt to import SQLAlchemy components
try:
    from sqlalchemy.orm.attributes import instance_state
    _SQLA_AVAILABLE = True
except ImportError:
    _SQLA_AVAILABLE = False
    instance_state = None

# Attempt to import Pydantic components
try:
    from pydantic import BaseModel
    _PYDANTIC_AVAILABLE = True
except ImportError:
    _PYDANTIC_AVAILABLE = False
    BaseModel = None


class SQLAlchemyModelToModelStrategy(ConversionStrategy):
    """
    Strategy for converting SQLAlchemy model instances to Pydantic/SQLModel instances.
    Internally converts the SQLAlchemy model to a dictionary first.
    """

    def can_handle(self, source: CanonicalType, target: CanonicalType) -> bool:
        """
        Returns True if source is SQLAlchemy model and target is Pydantic/SQLModel.
        """
        return (
            source.kind == "composite" and
            source.meta is not None and
            source.meta.get("origin_system") == "sqlalchemy_model" and
            target.kind == "composite" and
            target.meta is not None and
            target.meta.get("origin_system") in ("pydantic", "sqlmodel")
        )

    def convert(self, value: Any, context: ConversionContext) -> Any:
        """
        Convert an SQLAlchemy model instance to a Pydantic/SQLModel instance.

        Args:
            value: The SQLAlchemy model instance.
            context: The conversion context.

        Returns:
            An instance of the target Pydantic or SQLModel model.

        Raises:
            ConversionError: If conversion fails at any step.
            PolitipoError: If SQLAlchemy or Pydantic is not installed.
        """
        if not _SQLA_AVAILABLE:
            raise PolitipoError("SQLAlchemy is required for SQLAlchemyModelToModelStrategy")
        if not _PYDANTIC_AVAILABLE:
             # Check specifically if target is SQLModel which also needs Pydantic
             is_sqlmodel_target = context.target.meta and context.target.meta.get("origin_system") == "sqlmodel"
             if is_sqlmodel_target:
                 raise PolitipoError("Pydantic (dependency of SQLModel) is required for SQLAlchemyModelToModelStrategy")
             # Only raise if the target is explicitly Pydantic
             elif context.target.meta and context.target.meta.get("origin_system") == "pydantic":
                 raise PolitipoError("Pydantic is required for SQLAlchemyModelToModelStrategy")
             # If target system unknown or different, this strategy shouldn't have been selected anyway


        # 1. Convert SQLAlchemy Model to Dictionary
        try:
            # Basic check for SQLAlchemy instance
            if not hasattr(value, '__table__'):
                 try:
                      state = instance_state(value)
                      if not state: raise AttributeError
                 except (AttributeError, TypeError):
                      raise ConversionError(f"Expected an SQLAlchemy model instance, got {type(value)}")

            column_names = [c.name for c in value.__table__.columns]
            data_dict = {col: getattr(value, col) for col in column_names}
        except Exception as e:
            raise ConversionError(f"Failed to convert SQLAlchemy model {type(value).__name__} to dict: {e}") from e

        # 2. Get Target Pydantic/SQLModel Class
        if not context.target_type_system:
            raise ConversionError("Target type system (PydanticTypeSystem or SQLModelTypeSystem) not found in context")
        try:
            # Use the target system (Pydantic or SQLModel) to get the class
            model_class: Type = context.target_type_system.from_canonical(context.target)
            # Basic validation that we got a class, ideally check if it's a BaseModel subclass
            if not isinstance(model_class, type) or (_PYDANTIC_AVAILABLE and not issubclass(model_class, BaseModel)):
                 # Allow if Pydantic isn't installed but SQLModel might be the target (edge case)
                 if not (context.target.meta and context.target.meta.get("origin_system") == "sqlmodel"):
                      raise ConversionError(f"Target system did not return a valid Pydantic/SQLModel class for {context.target.name}")
        except Exception as e:
            raise ConversionError(f"Failed to get target Pydantic/SQLModel class: {e}") from e

        # 3. Instantiate Pydantic/SQLModel from Dictionary
        try:
            # Use the utility function which handles Pydantic v1/v2 and strict mode
            instance = create_model_instance_from_dict(model_class, data_dict, context.strict)
            return instance
        except Exception as e:
            # The helper raises ConversionError, but catch just in case
            raise ConversionError(f"Failed to create Pydantic/SQLModel instance {model_class.__name__} from dict: {e}") from e

```


---

_**Assistant**_

I'll create the four Python files for SQLAlchemy integration strategies in the politipo/core/conversion/strategies directory.

---

<details>
            <summary>Listed current directory • **33** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `generated-icon.png` |
| 📄 `test_results.txt` |
| 📁 `.upm` |
| 📄 `main.py` |
| 📄 `debug_constraints.py` |
| 📄 `simple_test.py` |
| 📄 `test_output.py` |
| 📄 `test_pandera.py` |
| 📄 `simple_test_results.txt` |
| 📄 `debug_constraints.txt` |
| 📁 `__pycache__` |
| 📄 `uv.lock` |
| 📄 `pyproject.toml` |
| 📁 `politipo` |
| 📁 `politipo.egg-info` |
| 📄 `.ccignore` |
| 📁 `old_tests` |
| 📄 `ABOUT_POLITIPO.md` |
| 📄 `replit.nix` |
| 📁 `dist` |
| 📄 `pydantic_test.py` |
| 📄 `pydantic_imports.txt` |
| 📁 `examples` |
| 📄 `README.md` |
| 📁 `.specstory` |
| 📁 `.cache` |
| 📁 `.config` |
| 📁 `.pytest_cache` |
| 📁 `.pythonlibs` |
| 📄 `.replit` |
| 📁 `.local` |
| 📄 `.gitignore` |

</details>

---

<details>
            <summary>Listed directory politipo • **8** results</summary>
        
| Name |
|-------|
| 📁 `__pycache__` |
| 📄 `schema_tools.py` |
| 📄 `__init__.py` |
| 📁 `plugins` |
| 📄 `type_converter.py` |
| 📄 `type_mapper.py` |
| 📁 `core` |
| 📁 `utils` |

</details>

---

<details>
            <summary>Listed directory politipo/core • **5** results</summary>
        
| Name |
|-------|
| 📁 `conversion` |
| 📁 `utils` |
| 📁 `types` |
| 📁 `__pycache__` |
| 📄 `errors.py` |

</details>

---

<details>
            <summary>Listed directory politipo/core/conversion • **8** results</summary>
        
| Name |
|-------|
| 📁 `utils` |
| 📁 `__pycache__` |
| 📄 `engine.py` |
| 📄 `strategy.py` |
| 📄 `__init__.py` |
| 📁 `strategies` |
| 📄 `context.py` |
| 📄 `graph.py` |

</details>

---

<details>
            <summary>Listed directory politipo/core/conversion/strategies • **10** results</summary>
        
| Name |
|-------|
| 📁 `__pycache__` |
| 📄 `polars_to_list.py` |
| 📄 `pandas_to_model_list.py` |
| 📄 `dict_to_model.py` |
| 📄 `__init__.py` |
| 📄 `model_to_dict.py` |
| 📄 `list_to_polars.py` |
| 📄 `list_to_pandas.py` |
| 📄 `base.py` |
| 📄 `pandas_to_pydantic.py` |

</details>

---

Read file: politipo/core/conversion/strategies/base.py

---

Read file: politipo/core/errors.py

---

Read file: politipo/core/conversion/context.py

---

<details>
            <summary>Listed directory politipo/core/conversion/utils • **3** results</summary>
        
| Name |
|-------|
| 📁 `__pycache__` |
| 📄 `instantiation.py` |
| 📄 `__init__.py` |

</details>

---

Read file: politipo/core/conversion/utils/instantiation.py

---

Read file: politipo/core/utils/pydantic.py

---

Read file: politipo/core/types/__init__.py

---

Read file: politipo/core/types/canonical.py

---

Read file: politipo/core/types/protocols.py

---

Now I'll implement the four requested Python files for the SQLAlchemy integration strategies:

---

```bash
mkdir -p politipo/core/conversion/strategies
```

```
runner@0dddef2ce518:~/workspace$ mkdir -p politipo/core/conversion/strategies
```

---

```diff
- 
+ # politipo/core/conversion/strategies/sqlalchemy_model_to_dict.py
+ 
+ from typing import Any, Dict
+ 
+ from politipo.core.types import CanonicalType
+ from politipo.core.conversion.context import ConversionContext
+ from politipo.core.conversion.strategies.base import ConversionStrategy
+ from politipo.core.errors import ConversionError, PolitipoError
+ 
+ # Attempt to import SQLAlchemy components, required for type checking and logic
+ try:
+     from sqlalchemy.orm.attributes import instance_state
+     _SQLA_AVAILABLE = True
+ except ImportError:
+     _SQLA_AVAILABLE = False
+     # Define dummy for type hinting if needed, though runtime checks handle absence
+     instance_state = None
+ 
+ 
+ class SQLAlchemyModelToDictStrategy(ConversionStrategy):
+     """Strategy for converting SQLAlchemy model instances to dictionaries."""
+ 
+     def can_handle(self, source: CanonicalType, target: CanonicalType) -> bool:
+         """
+         Returns True if the source is a SQLAlchemy model and the target is a dict.
+         Relies on metadata set by SQLAlchemyModelTypeSystem.
+         """
+         return (
+             source.kind == "composite" and
+             source.meta is not None and
+             source.meta.get("origin_system") == "sqlalchemy_model" and
+             target.kind == "container" and
+             target.name == "dict"
+         )
+ 
+     def convert(self, value: Any, context: ConversionContext) -> Dict[str, Any]:
+         """
+         Convert an SQLAlchemy model instance to a dictionary.
+ 
+         Args:
+             value: The SQLAlchemy model instance to convert.
+             context: The conversion context.
+ 
+         Returns:
+             A dictionary representing the model's column data.
+ 
+         Raises:
+             ConversionError: If the input is not a valid SQLAlchemy model instance
+                              or if conversion fails.
+             PolitipoError: If SQLAlchemy is not installed.
+         """
+         if not _SQLA_AVAILABLE:
+             raise PolitipoError("SQLAlchemy is required for SQLAlchemyModelToDictStrategy")
+ 
+         # Basic check: Does it look like an SQLAlchemy model instance?
+         # A more robust check might involve checking instance_state
+         if not hasattr(value, '__table__') or not hasattr(value, '__class__'):
+              # Try checking instance state as a more reliable indicator
+              try:
+                  state = instance_state(value)
+                  if not state:
+                      raise AttributeError # Not an instrumented instance
+              except (AttributeError, TypeError):
+                  raise ConversionError(f"Expected an SQLAlchemy model instance, got {type(value)}")
+ 
+         try:
+             # Extract column names from the model's table definition
+             column_names = [c.name for c in value.__table__.columns]
+ 
+             # Build the dictionary using getattr
+             data_dict = {}
+             for col_name in column_names:
+                 # Use getattr to retrieve the value; handle potential unloaded attributes
+                 # Note: This might trigger lazy loading if attributes are not loaded.
+                 # For complex scenarios, pre-loading attributes might be needed.
+                 try:
+                     data_dict[col_name] = getattr(value, col_name)
+                 except AttributeError:
+                     # This shouldn't typically happen for mapped columns, but handle defensively
+                     data_dict[col_name] = None # Or raise an error? Default to None for safety.
+ 
+             return data_dict
+         except AttributeError as e:
+              # Catch errors like value.__table__ not existing if the initial check failed
+             raise ConversionError(f"Failed to access SQLAlchemy model properties: {e}") from e
+         except Exception as e:
+             # Catch other potential errors during attribute access or processing
+             raise ConversionError(f"Failed to convert SQLAlchemy model instance to dict: {e}") from e 
```

---

```diff
- 
+ from typing import Any, Dict, Type
+ 
+ from politipo.core.types import CanonicalType
+ from politipo.core.conversion.context import ConversionContext
+ from politipo.core.conversion.strategies.base import ConversionStrategy
+ from politipo.core.errors import ConversionError, PolitipoError
+ 
+ # Attempt to import SQLAlchemy components
+ try:
+     from sqlalchemy.orm import DeclarativeMeta
+     _SQLA_AVAILABLE = True
+ except ImportError:
+     _SQLA_AVAILABLE = False
+     DeclarativeMeta = None
+ 
+ 
+ class DictToSQLAlchemyModelStrategy(ConversionStrategy):
+     """Strategy for converting dictionaries to SQLAlchemy model instances."""
+ 
+     def can_handle(self, source: CanonicalType, target: CanonicalType) -> bool:
+         """
+         Returns True if the source is a dict and the target is a SQLAlchemy model.
+         Relies on metadata set by SQLAlchemyModelTypeSystem.
+         """
+         return (
+             source.kind == "container" and
+             source.name == "dict" and
+             target.kind == "composite" and
+             target.meta is not None and
+             target.meta.get("origin_system") == "sqlalchemy_model"
+         )
+ 
+     def convert(self, value: Any, context: ConversionContext) -> Any:
+         """
+         Convert a dictionary to an SQLAlchemy model instance.
+ 
+         Args:
+             value: The dictionary to convert.
+             context: The conversion context containing target type information.
+ 
+         Returns:
+             An instance of the target SQLAlchemy model.
+ 
+         Raises:
+             ConversionError: If the input is not a dict, the target type system
+                              is missing, the target model class cannot be resolved,
+                              or instantiation fails.
+             PolitipoError: If SQLAlchemy is not installed.
+         """
+         if not _SQLA_AVAILABLE:
+             raise PolitipoError("SQLAlchemy is required for DictToSQLAlchemyModelStrategy")
+ 
+         if not isinstance(value, dict):
+             raise ConversionError(f"Expected dict, got {type(value)}")
+ 
+         # Get the target SQLAlchemy model class from the context
+         if not context.target_type_system:
+             raise ConversionError("Target type system (SQLAlchemyModelTypeSystem) not found in context")
+ 
+         try:
+             # Use the target system to reconstruct the model class from the canonical type
+             model_class: Type = context.target_type_system.from_canonical(context.target)
+             if not isinstance(model_class, type) or not hasattr(model_class, '__table__'):
+                  # Check if it's a DeclarativeMeta type
+                  if not isinstance(getattr(model_class, '__class__', None), DeclarativeMeta):
+                       raise ConversionError(f"Target system did not return a valid SQLAlchemy model class for {context.target.name}")
+ 
+         except NotImplementedError:
+             raise ConversionError(f"Target system '{context.target_type_system.name}' cannot reconstruct model from canonical type.")
+         except Exception as e:
+             raise ConversionError(f"Failed to get target SQLAlchemy model class from canonical type: {e}") from e
+ 
+         # Instantiate the model
+         try:
+             # Filter dict keys based on model columns if not in strict mode
+             data_to_instantiate = value
+             if not context.strict:
+                 valid_column_names = {c.name for c in model_class.__table__.columns}
+                 data_to_instantiate = {k: v for k, v in value.items() if k in valid_column_names}
+ 
+             # Instantiate using **kwargs
+             # Note: This assumes the dictionary keys match model attribute names.
+             # Complex relationships or non-column attributes might require custom handling
+             # or should be set after initial instantiation if needed.
+             instance = model_class(**data_to_instantiate)
+             return instance
+         except TypeError as e:
+             # Catch errors like unexpected keyword arguments
+              if context.strict:
+                  raise ConversionError(f"Failed to instantiate {model_class.__name__} with data {value}. Strict mode error: {e}") from e
+              else:
+                  # Try again without filtering if initial filtering failed, though unlikely
+                  try:
+                      return model_class(**value)
+                  except Exception as final_e:
+                       raise ConversionError(f"Failed to instantiate {model_class.__name__} even in non-strict mode: {final_e}") from final_e
+         except Exception as e:
+             # Catch other potential instantiation errors
+             raise ConversionError(f"Failed to create SQLAlchemy model instance of {model_class.__name__}: {e}") from e 
```

---

```diff
- 
+ # politipo/core/conversion/strategies/model_to_sqlalchemy_model.py
+ 
+ from typing import Any, Dict, Type
+ 
+ from politipo.core.types import CanonicalType
+ from politipo.core.conversion.context import ConversionContext
+ from politipo.core.conversion.strategies.base import ConversionStrategy
+ from politipo.core.errors import ConversionError, PolitipoError
+ from politipo.core.utils.pydantic import get_pydantic_version # To check for model_dump/dict
+ 
+ # Attempt to import SQLAlchemy components
+ try:
+     from sqlalchemy.orm import DeclarativeMeta
+     _SQLA_AVAILABLE = True
+ except ImportError:
+     _SQLA_AVAILABLE = False
+     DeclarativeMeta = None
+ 
+ # Attempt to import Pydantic components
+ try:
+     from pydantic import BaseModel
+     _PYDANTIC_AVAILABLE = True
+ except ImportError:
+     _PYDANTIC_AVAILABLE = False
+     BaseModel = None
+ 
+ 
+ class ModelToSQLAlchemyModelStrategy(ConversionStrategy):
+     """
+     Strategy for converting Pydantic/SQLModel instances to SQLAlchemy model instances.
+     Internally converts the source model to a dictionary first.
+     """
+ 
+     def can_handle(self, source: CanonicalType, target: CanonicalType) -> bool:
+         """
+         Returns True if source is Pydantic/SQLModel and target is SQLAlchemy model.
+         """
+         return (
+             source.kind == "composite" and
+             source.meta is not None and
+             source.meta.get("origin_system") in ("pydantic", "sqlmodel") and
+             target.kind == "composite" and
+             target.meta is not None and
+             target.meta.get("origin_system") == "sqlalchemy_model"
+         )
+ 
+     def convert(self, value: Any, context: ConversionContext) -> Any:
+         """
+         Convert a Pydantic/SQLModel instance to an SQLAlchemy model instance.
+ 
+         Args:
+             value: The Pydantic or SQLModel instance.
+             context: The conversion context.
+ 
+         Returns:
+             An instance of the target SQLAlchemy model.
+ 
+         Raises:
+             ConversionError: If conversion fails at any step.
+             PolitipoError: If SQLAlchemy or Pydantic is not installed.
+         """
+         if not _SQLA_AVAILABLE:
+             raise PolitipoError("SQLAlchemy is required for ModelToSQLAlchemyModelStrategy")
+         if not _PYDANTIC_AVAILABLE:
+              # Check specifically if it's a SQLModel type which also needs Pydantic
+              is_sqlmodel_source = context.source.meta and context.source.meta.get("origin_system") == "sqlmodel"
+              if is_sqlmodel_source:
+                  raise PolitipoError("Pydantic (dependency of SQLModel) is required for ModelToSQLAlchemyModelStrategy")
+              # Only raise if the source is explicitly Pydantic
+              elif context.source.meta and context.source.meta.get("origin_system") == "pydantic":
+                  raise PolitipoError("Pydantic is required for ModelToSQLAlchemyModelStrategy")
+              # If source system unknown or different, let it proceed, maybe it has .dict() anyway
+ 
+ 
+         # 1. Convert Source Model (Pydantic/SQLModel) to Dictionary
+         try:
+             if hasattr(value, "model_dump"):  # Pydantic v2 preferred
+                 data_dict = value.model_dump()
+             elif hasattr(value, "dict"):      # Pydantic v1 fallback
+                 data_dict = value.dict()
+             else:
+                 raise ConversionError(f"Source object {type(value)} does not have 'model_dump' or 'dict' method.")
+         except Exception as e:
+             raise ConversionError(f"Failed to convert source model {type(value).__name__} to dict: {e}") from e
+ 
+         # 2. Get Target SQLAlchemy Model Class
+         if not context.target_type_system:
+             raise ConversionError("Target type system (SQLAlchemyModelTypeSystem) not found in context")
+         try:
+             model_class: Type = context.target_type_system.from_canonical(context.target)
+             if not isinstance(model_class, type) or not hasattr(model_class, '__table__'):
+                  # Check if it's a DeclarativeMeta type
+                  if not isinstance(getattr(model_class, '__class__', None), DeclarativeMeta):
+                       raise ConversionError(f"Target system did not return a valid SQLAlchemy model class for {context.target.name}")
+         except Exception as e:
+             raise ConversionError(f"Failed to get target SQLAlchemy model class: {e}") from e
+ 
+         # 3. Instantiate SQLAlchemy Model from Dictionary
+         try:
+             # Filter dict keys based on model columns if not in strict mode
+             data_to_instantiate = data_dict
+             if not context.strict:
+                 valid_column_names = {c.name for c in model_class.__table__.columns}
+                 data_to_instantiate = {k: v for k, v in data_dict.items() if k in valid_column_names}
+ 
+             instance = model_class(**data_to_instantiate)
+             return instance
+         except TypeError as e:
+              if context.strict:
+                  raise ConversionError(f"Failed to instantiate {model_class.__name__} from dict {data_dict}. Strict mode error: {e}") from e
+              else:
+                  # Try again without filtering if initial filtering failed
+                  try:
+                      return model_class(**data_dict)
+                  except Exception as final_e:
+                      raise ConversionError(f"Failed to instantiate {model_class.__name__} even in non-strict mode: {final_e}") from final_e
+         except Exception as e:
+             raise ConversionError(f"Failed to create SQLAlchemy model instance {model_class.__name__} from dict: {e}") from e 
```

---

```diff
- 
+ # politipo/core/conversion/strategies/sqlalchemy_model_to_model.py
+ 
+ from typing import Any, Dict, Type
+ 
+ from politipo.core.types import CanonicalType
+ from politipo.core.conversion.context import ConversionContext
+ from politipo.core.conversion.strategies.base import ConversionStrategy
+ from politipo.core.errors import ConversionError, PolitipoError
+ from politipo.core.conversion.utils.instantiation import create_model_instance_from_dict # Helper for Pydantic/SQLModel
+ 
+ # Attempt to import SQLAlchemy components
+ try:
+     from sqlalchemy.orm.attributes import instance_state
+     _SQLA_AVAILABLE = True
+ except ImportError:
+     _SQLA_AVAILABLE = False
+     instance_state = None
+ 
+ # Attempt to import Pydantic components
+ try:
+     from pydantic import BaseModel
+     _PYDANTIC_AVAILABLE = True
+ except ImportError:
+     _PYDANTIC_AVAILABLE = False
+     BaseModel = None
+ 
+ 
+ class SQLAlchemyModelToModelStrategy(ConversionStrategy):
+     """
+     Strategy for converting SQLAlchemy model instances to Pydantic/SQLModel instances.
+     Internally converts the SQLAlchemy model to a dictionary first.
+     """
+ 
+     def can_handle(self, source: CanonicalType, target: CanonicalType) -> bool:
+         """
+         Returns True if source is SQLAlchemy model and target is Pydantic/SQLModel.
+         """
+         return (
+             source.kind == "composite" and
+             source.meta is not None and
+             source.meta.get("origin_system") == "sqlalchemy_model" and
+             target.kind == "composite" and
+             target.meta is not None and
+             target.meta.get("origin_system") in ("pydantic", "sqlmodel")
+         )
+ 
+     def convert(self, value: Any, context: ConversionContext) -> Any:
+         """
+         Convert an SQLAlchemy model instance to a Pydantic/SQLModel instance.
+ 
+         Args:
+             value: The SQLAlchemy model instance.
+             context: The conversion context.
+ 
+         Returns:
+             An instance of the target Pydantic or SQLModel model.
+ 
+         Raises:
+             ConversionError: If conversion fails at any step.
+             PolitipoError: If SQLAlchemy or Pydantic is not installed.
+         """
+         if not _SQLA_AVAILABLE:
+             raise PolitipoError("SQLAlchemy is required for SQLAlchemyModelToModelStrategy")
+         if not _PYDANTIC_AVAILABLE:
+              # Check specifically if target is SQLModel which also needs Pydantic
+              is_sqlmodel_target = context.target.meta and context.target.meta.get("origin_system") == "sqlmodel"
+              if is_sqlmodel_target:
+                  raise PolitipoError("Pydantic (dependency of SQLModel) is required for SQLAlchemyModelToModelStrategy")
+              # Only raise if the target is explicitly Pydantic
+              elif context.target.meta and context.target.meta.get("origin_system") == "pydantic":
+                  raise PolitipoError("Pydantic is required for SQLAlchemyModelToModelStrategy")
+              # If target system unknown or different, this strategy shouldn't have been selected anyway
+ 
+ 
+         # 1. Convert SQLAlchemy Model to Dictionary
+         try:
+             # Basic check for SQLAlchemy instance
+             if not hasattr(value, '__table__'):
+                  try:
+                       state = instance_state(value)
+                       if not state: raise AttributeError
+                  except (AttributeError, TypeError):
+                       raise ConversionError(f"Expected an SQLAlchemy model instance, got {type(value)}")
+ 
+             column_names = [c.name for c in value.__table__.columns]
+             data_dict = {col: getattr(value, col) for col in column_names}
+         except Exception as e:
+             raise ConversionError(f"Failed to convert SQLAlchemy model {type(value).__name__} to dict: {e}") from e
+ 
+         # 2. Get Target Pydantic/SQLModel Class
+         if not context.target_type_system:
+             raise ConversionError("Target type system (PydanticTypeSystem or SQLModelTypeSystem) not found in context")
+         try:
+             # Use the target system (Pydantic or SQLModel) to get the class
+             model_class: Type = context.target_type_system.from_canonical(context.target)
+             # Basic validation that we got a class, ideally check if it's a BaseModel subclass
+             if not isinstance(model_class, type) or (_PYDANTIC_AVAILABLE and not issubclass(model_class, BaseModel)):
+                  # Allow if Pydantic isn't installed but SQLModel might be the target (edge case)
+                  if not (context.target.meta and context.target.meta.get("origin_system") == "sqlmodel"):
+                       raise ConversionError(f"Target system did not return a valid Pydantic/SQLModel class for {context.target.name}")
+         except Exception as e:
+             raise ConversionError(f"Failed to get target Pydantic/SQLModel class: {e}") from e
+ 
+         # 3. Instantiate Pydantic/SQLModel from Dictionary
+         try:
+             # Use the utility function which handles Pydantic v1/v2 and strict mode
+             instance = create_model_instance_from_dict(model_class, data_dict, context.strict)
+             return instance
+         except Exception as e:
+             # The helper raises ConversionError, but catch just in case
+             raise ConversionError(f"Failed to create Pydantic/SQLModel instance {model_class.__name__} from dict: {e}") from e 
```

---

Model failed to call the tool with correct arguments.

---

Read file: politipo/core/conversion/strategies/__init__.py

---

```diff
  from politipo.core.conversion.strategies.list_to_polars import ListToPolarsStrategy
  from politipo.core.conversion.strategies.polars_to_list import PolarsToListStrategy
+ from politipo.core.conversion.strategies.sqlalchemy_model_to_dict import SQLAlchemyModelToDictStrategy
+ from politipo.core.conversion.strategies.dict_to_sqlalchemy_model import DictToSQLAlchemyModelStrategy
+ from politipo.core.conversion.strategies.model_to_sqlalchemy_model import ModelToSQLAlchemyModelStrategy
+ from politipo.core.conversion.strategies.sqlalchemy_model_to_model import SQLAlchemyModelToModelStrategy
  
  __all__ = [
      "ListToPolarsStrategy",
      "PolarsToListStrategy",
+     "SQLAlchemyModelToDictStrategy",
+     "DictToSQLAlchemyModelStrategy",
+     "ModelToSQLAlchemyModelStrategy",
+     "SQLAlchemyModelToModelStrategy",
  ] 
```

---

<details>
            <summary>Listed directory politipo/core/conversion/strategies • **14** results</summary>
        
| Name |
|-------|
| 📄 `__init__.py` |
| 📄 `sqlalchemy_model_to_model.py` |
| 📄 `model_to_sqlalchemy_model.py` |
| 📄 `dict_to_sqlalchemy_model.py` |
| 📄 `sqlalchemy_model_to_dict.py` |
| 📁 `__pycache__` |
| 📄 `polars_to_list.py` |
| 📄 `pandas_to_model_list.py` |
| 📄 `dict_to_model.py` |
| 📄 `model_to_dict.py` |
| 📄 `list_to_polars.py` |
| 📄 `list_to_pandas.py` |
| 📄 `base.py` |
| 📄 `pandas_to_pydantic.py` |

</details>

---

I've successfully implemented all four SQLAlchemy integration strategies for the Politipo conversion engine:

1. `sqlalchemy_model_to_dict.py` - Converts SQLAlchemy model instances to dictionaries
2. `dict_to_sqlalchemy_model.py` - Converts dictionaries to SQLAlchemy model instances
3. `model_to_sqlalchemy_model.py` - Converts Pydantic/SQLModel instances to SQLAlchemy model instances
4. `sqlalchemy_model_to_model.py` - Converts SQLAlchemy model instances to Pydantic/SQLModel instances

Each strategy follows best practices:

- Proper error handling with specific error messages
- Conditional imports with graceful fallbacks
- Support for both strict and non-strict conversion modes
- Defensive programming with multiple validation checks
- Clear documentation explaining functionality and requirements

I've also updated the `__init__.py` file to expose these new strategies, making them available for registration with your `ConversionEngine` instance as shown in your example code.

To use these strategies, you'll need to register them with your engine as demonstrated in your instructions:

```python
engine.register_strategy(SQLAlchemyModelToDictStrategy())
engine.register_strategy(DictToSQLAlchemyModelStrategy())
engine.register_strategy(ModelToSQLAlchemyModelStrategy())
engine.register_strategy(SQLAlchemyModelToModelStrategy())
```

---



---

